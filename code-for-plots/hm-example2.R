## simple simulator 
f <- function(x) {
  if( x <= 1 & x >= 0 ) {
    res <- 0.6 * sinpi(2*x) + 2*cospi(3*x) + sinpi(4*x) + 2*x
  } else {
    res <- NULL
  }
  res
}
f.vec <- Vectorize(f)
y = function(x, sig  = sqrt(0.75)) {
  f.vec(x) + sig * rnorm(length(x))
}

xx = seq(0,1,length=1000)

## first numerically maximise
opt <- optim(xx[which.max(f.vec(xx))], fn = function(x) -1*f.vec(x),
             method  = "Brent",  lower  = 1e-8, upper = 1-1e-8)
y_obs =  -opt$value
v_obs = 0.25
set.seed(12345)
n = 50
x_train = runif(n)
y_train = y(x_train)
plot(x_train, y_train)
mlefit = hetGP::mleHomGP(
  X = x_train,
  Z = y_train,
  covtype = "Gaussian")
  
implaus = function(x, y_obs, m, v) {
  (y_obs - m)/sqrt(v)
}
x = seq(0, 1, length = 500)
posterior = predict(mlefit, x = as.matrix(x))
m = posterior$mean
v0 = posterior$sd2 + posterior$nugs
lo = m - 2*sqrt(v0)
hi = m + 2*sqrt(v0)
par(mfrow = c(1,2))
plot(x, m, type = "l", ylim = c(-6, 7), xlim = c(0,1),
     main = "Emulator and Data", ylab =  "y(x)",
     col = 2)
clr = rgb(1, 0, 0, alpha = 0.3)
hi2 = rep(y_obs - 2*sqrt(v_obs), length(x))
lo2 = rep(y_obs + 2*sqrt(v_obs), length(x))
polygon(c((x), rev(x)), c((lo), rev(hi)), col = clr, border = "transparent")
polygon(c((x), rev(x)), c(lo2, rev(hi2)), col = clr, border = "transparent")
lines(x, rep(y_obs, length(x)))
points(x_train, y_train, pch = 3)
legend("bottomleft", col = c(2, clr, 1), lty = rep(1, 3), 
       legend = c("Mean", "Uncertainty", "Data"), bty = "n",
       cex = 0.8)
imp = (y_obs - m)/sqrt(v0 + v_obs)
## imp plot
plot(x, imp, type = "l", ylim = c(-2, 5), xlim = c(0, 1),
     main = "Implausibility", ylab = "I(x)", col = NULL)

lines(x[imp<3], imp[imp<3], col = "green")
lines(x[imp>=3], imp[imp>=3], col = "red")
abline(h = 3, lwd = 4)
legend("bottomleft", col = c("black", "red", "green"), lty = rep(1, 3), 
       legend = c("Cut off", "Implausible", "NROY"), bty = "n",
       cex  = 0.8)
mean(imp < 3)
1 - mean(imp < 3)
## wave 2
## design generated by rejection sampling ...
## 100*mean(imp < 3 )%  of space is NROY
## if I want N points in the NROY space then I should
## generate N/mean
set.seed(987)
n_cand = 1 + floor(n/mean(imp < 3))
x2 = x[imp < 3]
d = x[2] - x[1]
breaks = which(diff(x2) > d + .Machine$double.eps)
lims = matrix(ncol = 2, nrow = 3)
lims[1, ] = c(0, x2[breaks[1]])
lims[2, ] = c(x2[1 + breaks[1]], x2[breaks[2]])
lims[3, ] = c(x2[breaks[2] + 1], 1)

x_train2 = c(
  runif(n, min = lims[1,1], max = lims[1,2]),
  runif(n, min = lims[2,1], max = lims[2,2]),
  runif(n, min = lims[3,1], max = lims[3,2]))

m = posterior$mean
v0 = posterior$sd2 + posterior$nugs
I_cand = (y_obs - m)/sqrt(v0 + v_obs)
nroy_ind = I_cand < 3
nroy_ind2 = nroy_ind
nroy_ind2[!nroy_ind2] = rep(NA, sum(!nroy_ind2))
x_train2 = sort(x_train2)
y_train2 = y(x_train2)
mlefit = hetGP::mleHomGP(
  X = x_train2,
  Z = y_train2,
  covtype = "Gaussian")

posterior = predict(mlefit, x = as.matrix(x2))
m = posterior$mean
v0 = posterior$sd2 + posterior$nugs
lo = m - 2*sqrt(v0)
hi = m + 2*sqrt(v0)
par(mfrow = c(1,2))

##  compute the number of gaps ...
d = diff(x)[1] ## the normal distance
nn = length(x2)

plot(x2[1:breaks[1]], m[1:breaks[1]], type = "l", ylim = c(-6, 7), xlim = c(0,1),
     main = "Emulator and Data", ylab =  "y(x)", xlab = "x",
     col = 2)
  lines(
    x2[(breaks[1]+1):breaks[2]], m[(breaks[1]+1):breaks[2]],
    col = 2 )
  lines(
    x2[(breaks[2]+1):nn], m[(breaks[2]+1):nn],
    col = 2 )

clr = rgb(1, 0, 0, alpha = 0.3)
hi2 = rep(y_obs - 2*sqrt(v_obs), length(x2))
lo2 = rep(y_obs + 2*sqrt(v_obs), length(x2))
polygon(c((x2), rev(x2)), c((lo2), rev(hi2)), col = clr, border = "transparent")
polygon(c(x, rev(x)),
        c(lo2, rev(hi2)),
        col = clr, border = "transparent")
polygon(c((x2[1:breaks[1]]), rev(x2[1:breaks[1]])),
        c(lo[1:breaks[1]], rev(hi[1:breaks[1]])),
        col = clr, border = "transparent")
polygon(c((x2[(breaks[1]+1):breaks[2]]), rev(x2[(breaks[1]+1):breaks[2]])),
        c(lo[(breaks[1]+1):breaks[2]], rev(hi[(breaks[1]+1):breaks[2]])),
        col = clr, border = "transparent")
polygon(c((x2[(breaks[2]+1):nn]), rev(x2[(breaks[2]+1):nn])),
        c(lo[(breaks[2]+1):nn], rev(hi[(breaks[2]+1):nn])),
        col = clr, border = "transparent")
lines(x, rep(y_obs, length(x)))
points(x_train2, y_train2, pch = 3)
legend("bottomleft", col = c(2, clr, 1), lty = rep(1, 3), 
       legend = c("Mean", "Uncertainty", "Data"), bty = "n",
       cex  = 0.8)
imp0 = (y_obs - m)/sqrt(v0 + v_obs)
## imp plot
plot(x2, imp0, type = "l", ylim = c(-2, 5), xlim = c(0,1),
     main = "Implausibility", ylab = "I(x)", col = NULL)
indices = 1:breaks[1]
imp2_all = rep(NA, length(x2))
imp2 = imp0[indices]
imp2_all[indices] = imp0[indices]
lines(x2[indices][imp2 < 3], imp2[imp2 < 3], col = "green")
lines(x2[indices][imp2 >= 3], imp2[imp2 >= 3], col = "red")
indices = (1 + breaks[1]):breaks[2]
imp2 = imp0[indices]
imp2_all[indices] = imp0[indices]

lines(x2[indices][imp2 < 3], imp2[imp2 < 3], col = "green")
lines(x2[indices][imp2 >= 3], imp2[imp2 >= 3], col = "red")
indices = -(1:breaks[2])  
imp2 = imp0[indices]
imp2_all[indices] = imp0[indices]

lines(x2[indices][imp2 < 3], imp2[imp2 < 3], col = "green")
lines(x2[indices][imp2 >= 3], imp2[imp2 >= 3], col = "red")
abline(h = 3, lwd = 3)
legend("bottomleft", col = c("black", "red", "green"), lty = rep(1, 3), 
       legend = c("Cut off", "Implausible", "NROY"), bty = "n",
       cex  = 0.8)
mean(imp < 3)
mean(imp2 < 3)
100 * mean(imp0 < 3)*mean(imp < 3)
